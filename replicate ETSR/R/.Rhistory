if (is.null(strata)) {
return(stratified_ATE(DF, pop_size))
} else if (strata == 'propensity stratification') {
assert("For propensity score stratification you need first to add the propensity_score and prop_Score_quantile columns into the dataframe.", {
("propensity_score" %in% names(DF))
("prop_score_quantile" %in% names(DF))
})
ATE <- 0
variance <- 0
for (q in unique(DF$prop_score_quantile)){
stratum_data <- DF[DF$prop_score_quantile == q,]
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
}
}
pop_size = nrow(DF)
if (is.null(strata)) {
return(stratified_ATE(DF, pop_size))
} else if (strata == 'propensity stratification') {
assert("For propensity score stratification you need first to add the propensity_score and prop_Score_quantile columns into the dataframe.", {
("propensity_score" %in% names(DF))
("prop_score_quantile" %in% names(DF))
})
ATE <- 0
variance <- 0
for (q in unique(DF$prop_score_quantile)){
stratum_data <- DF[DF$prop_score_quantile == q,]
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum
}
}
groupbyDF <- DF %>% group_by(covariates)
groupbyDF <- DF %>% group_by(c('gender','country'))
groupbyDF <- DF %>% group_by('gender','country')
groupbyDF
for (df in groupbyDF){print(df)}
split(DF, interaction(DF$gender, DF$country))
for (df in split(DF, interaction(DF$gender, DF$country))){print(df)}
for (df in split(DF, interaction('gender','country'))){print(df)}
for (df in split(DF, interaction(c(DF$gender,DF$country)))){print(df)}
for (df in split(DF, interaction(DF$gender,DF$country))){print(df)}
# ATE
ATE <- function(DF, strata){
pop_size = nrow(DF)
if (is.null(strata)) {
return(stratified_ATE(DF, pop_size))
} else if (strata == 'propensity stratification') {
assert("For propensity score stratification you need first to add the propensity_score and prop_Score_quantile columns into the dataframe.", {
("propensity_score" %in% names(DF))
("prop_score_quantile" %in% names(DF))
})
ATE <- 0
variance <- 0
for (q in unique(DF$prop_score_quantile)){
stratum_data <- DF[DF$prop_score_quantile == q,]
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance)) else {
# ATE
ATE <- function(DF, strata){
pop_size = nrow(DF)
if (is.null(strata)) {
return(stratified_ATE(DF, pop_size))
} else if (strata == 'propensity stratification') {
assert("For propensity score stratification you need first to add the propensity_score and prop_Score_quantile columns into the dataframe.", {
("propensity_score" %in% names(DF))
("prop_score_quantile" %in% names(DF))
})
ATE <- 0
variance <- 0
for (q in unique(DF$prop_score_quantile)){
stratum_data <- DF[DF$prop_score_quantile == q,]
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))} else {
ATE <- 0
variance <- 0
for (stratum_data in split(DF, interaction(DF$gender, DF$country))){
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))}
}
A$propensity_score <- propensity_score(A, covariates, MinMaxScaler, TRUE)
q <- 5
A$prop_score_quantile <- with(A, cut(propensity_score, breaks = qu <- quantile(propensity_score, probs = seq(0,1, by=1/q)), labels = names(qu)[-1], include.lowest=TRUE))
ATE(A, 'propensity stratification')
# ATE
ATE <- function(DF, strata){
pop_size = nrow(DF)
if (is.null(strata)) {
return(stratified_ATE(DF, pop_size))
} else if (strata == 'propensity stratification') {
assert("For propensity score stratification you need first to add the propensity_score and prop_Score_quantile columns into the dataframe.", {
("propensity_score" %in% names(DF))
("prop_score_quantile" %in% names(DF))
})
ATE <- 0
variance <- 0
for (q in unique(DF$prop_score_quantile)){
stratum_data <- DF[DF$prop_score_quantile == q,]
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
print(stratified_ATE_variance)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))} else {
ATE <- 0
variance <- 0
for (stratum_data in split(DF, interaction(DF$gender, DF$country))){
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))}
}
ATE(A, 'propensity stratification')
print(stratum_data)
# ATE
ATE <- function(DF, strata){
pop_size = nrow(DF)
if (is.null(strata)) {
return(stratified_ATE(DF, pop_size))
} else if (strata == 'propensity stratification') {
assert("For propensity score stratification you need first to add the propensity_score and prop_Score_quantile columns into the dataframe.", {
("propensity_score" %in% names(DF))
("prop_score_quantile" %in% names(DF))
})
ATE <- 0
variance <- 0
for (q in unique(DF$prop_score_quantile)){
stratum_data <- DF[DF$prop_score_quantile == q,]
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
print(stratum_data)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))} else {
ATE <- 0
variance <- 0
for (stratum_data in split(DF, interaction(DF$gender, DF$country))){
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))}
}
ATE(A, 'propensity stratification')
stratified_ATE(DF, nrow(DF))
stratified_ATE <- function(DF_group, pop_size) {
# Compute the average treatment effect on the specific stratum represented in DF_group.
# DF_group:  dataframe,
# pop_size:  size of the entire population from which the group comes from.
n_treated <- nrow(DF[DF$treatment == 1,])
n_untreated <- nrow(DF[DF$treatment == 0,])
assert("One group among treated/untreated is empty with this stratification", {
(n_treated!=0)
(n_untreated!=0)
})
avg_outcome_treated <- sum(DF_group$treatment * DF_group$Y) /  n_treated
avg_outcome_untreated <- sum((1-DF_group$treatment) * DF_group$Y) /  n_untreated
print(avg_outcome_untreated)
var_treated <- sum((DF_group$treatment * DF_group$Y - avg_outcome_treated)^2) / (n_treated-1)
var_untreated <- sum(((1-DF_group$treatment) * DF_group$Y - avg_outcome_untreated)^2) / (n_untreated-1)
size_group <- nrow(DF_group)
ATE_group <- (size_group/pop_size) * (avg_outcome_treated - avg_outcome_untreated)
variance_group <- (size_group/pop_size)^2 * (var_treated/n_treated + var_untreated/n_untreated)
return(c(ATE_group, variance_group))
}
stratified_ATE(DF, nrow(DF))
stratified_ATE <- function(DF_group, pop_size) {
# Compute the average treatment effect on the specific stratum represented in DF_group.
# DF_group:  dataframe,
# pop_size:  size of the entire population from which the group comes from.
n_treated <- nrow(DF[DF$treatment == 1,])
n_untreated <- nrow(DF[DF$treatment == 0,])
assert("One group among treated/untreated is empty with this stratification", {
(n_treated!=0)
(n_untreated!=0)
})
avg_outcome_treated <- sum(DF_group$treatment * DF_group$Y) /  n_treated
avg_outcome_untreated <- sum((1-DF_group$treatment) * DF_group$Y) /  n_untreated
print(DF_group$treatment * DF_group$Y)
var_treated <- sum((DF_group$treatment * DF_group$Y - avg_outcome_treated)^2) / (n_treated-1)
var_untreated <- sum(((1-DF_group$treatment) * DF_group$Y - avg_outcome_untreated)^2) / (n_untreated-1)
size_group <- nrow(DF_group)
ATE_group <- (size_group/pop_size) * (avg_outcome_treated - avg_outcome_untreated)
variance_group <- (size_group/pop_size)^2 * (var_treated/n_treated + var_untreated/n_untreated)
return(c(ATE_group, variance_group))
}
stratified_ATE(DF, nrow(DF))
stratified_ATE <- function(DF_group, pop_size) {
# Compute the average treatment effect on the specific stratum represented in DF_group.
# DF_group:  dataframe,
# pop_size:  size of the entire population from which the group comes from.
n_treated <- nrow(DF[DF$treatment == 1,])
n_untreated <- nrow(DF[DF$treatment == 0,])
assert("One group among treated/untreated is empty with this stratification", {
(n_treated!=0)
(n_untreated!=0)
})
avg_outcome_treated <- sum(DF_group$treatment * DF_group$Y) /  n_treated
avg_outcome_untreated <- sum((1-DF_group$treatment) * DF_group$Y) /  n_untreated
print(DF_group$treatment)
var_treated <- sum((DF_group$treatment * DF_group$Y - avg_outcome_treated)^2) / (n_treated-1)
var_untreated <- sum(((1-DF_group$treatment) * DF_group$Y - avg_outcome_untreated)^2) / (n_untreated-1)
size_group <- nrow(DF_group)
ATE_group <- (size_group/pop_size) * (avg_outcome_treated - avg_outcome_untreated)
variance_group <- (size_group/pop_size)^2 * (var_treated/n_treated + var_untreated/n_untreated)
return(c(ATE_group, variance_group))
}
stratified_ATE(DF, nrow(DF))
stratified_ATE <- function(DF_group, pop_size) {
# Compute the average treatment effect on the specific stratum represented in DF_group.
# DF_group:  dataframe,
# pop_size:  size of the entire population from which the group comes from.
n_treated <- nrow(DF[DF$treatment == 1,])
n_untreated <- nrow(DF[DF$treatment == 0,])
assert("One group among treated/untreated is empty with this stratification", {
(n_treated!=0)
(n_untreated!=0)
})
avg_outcome_treated <- sum(DF_group$treatment * DF_group$Y) /  n_treated
avg_outcome_untreated <- sum((1-DF_group$treatment) * DF_group$Y) /  n_untreated
print(DF_group$Y)
var_treated <- sum((DF_group$treatment * DF_group$Y - avg_outcome_treated)^2) / (n_treated-1)
var_untreated <- sum(((1-DF_group$treatment) * DF_group$Y - avg_outcome_untreated)^2) / (n_untreated-1)
size_group <- nrow(DF_group)
ATE_group <- (size_group/pop_size) * (avg_outcome_treated - avg_outcome_untreated)
variance_group <- (size_group/pop_size)^2 * (var_treated/n_treated + var_untreated/n_untreated)
return(c(ATE_group, variance_group))
}
stratified_ATE(DF, nrow(DF))
View(DF)
name_DF <- "DF_associations_N=41341_2023-01-05.csv"
DF <- read.csv(file.path("..", "..", "simulate data", "datasets", name_DF), header=TRUE)
identifiers <- list("family.name" = "jaro-winkler",
"gender" = "strict",
"country" = "strict",
"birth.year" = "large")
covariates <- c('X1', 'X2', 'X3', 'X4', 'X5')
overlap <- DF[sample(nrow(DF),150),]
A <- rbind(DF[sample(nrow(DF),450),], overlap)
A <- A[,!names(A) %in% c("Y")]
rownames(A) <- NULL
head(A)
B <- rbind(DF[sample(nrow(DF),350),], overlap)[,append(names(identifiers),"Y")]
rownames(B) <- NULL
head(B)
View(DF)
stratified_ATE <- function(DF_group, pop_size) {
# Compute the average treatment effect on the specific stratum represented in DF_group.
# DF_group:  dataframe,
# pop_size:  size of the entire population from which the group comes from.
n_treated <- nrow(DF[DF$treatment == 1,])
n_untreated <- nrow(DF[DF$treatment == 0,])
assert("One group among treated/untreated is empty with this stratification", {
(n_treated!=0)
(n_untreated!=0)
})
avg_outcome_treated <- sum(DF_group$treatment * DF_group$Y) /  n_treated
avg_outcome_untreated <- sum((1-DF_group$treatment) * DF_group$Y) /  n_untreated
var_treated <- sum((DF_group$treatment * DF_group$Y - avg_outcome_treated)^2) / (n_treated-1)
var_untreated <- sum(((1-DF_group$treatment) * DF_group$Y - avg_outcome_untreated)^2) / (n_untreated-1)
size_group <- nrow(DF_group)
ATE_group <- (size_group/pop_size) * (avg_outcome_treated - avg_outcome_untreated)
variance_group <- (size_group/pop_size)^2 * (var_treated/n_treated + var_untreated/n_untreated)
return(c(ATE_group, variance_group))
}
stratified_ATE(DF, nrow(DF))
# ATE
ATE <- function(DF, strata){
pop_size = nrow(DF)
if (is.null(strata)) {
return(stratified_ATE(DF, pop_size))
} else if (strata == 'propensity stratification') {
assert("For propensity score stratification you need first to add the propensity_score and prop_Score_quantile columns into the dataframe.", {
("propensity_score" %in% names(DF))
("prop_score_quantile" %in% names(DF))
})
ATE <- 0
variance <- 0
for (q in unique(DF$prop_score_quantile)){
stratum_data <- DF[DF$prop_score_quantile == q,]
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
print(stratum_data)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))} else {
ATE <- 0
variance <- 0
for (stratum_data in split(DF, interaction(DF$gender, DF$country))){
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))}
}
# ATE
ATE <- function(DF, strata){
pop_size = nrow(DF)
if (is.null(strata)) {
return(stratified_ATE(DF, pop_size))
} else if (strata == 'propensity stratification') {
assert("For propensity score stratification you need first to add the propensity_score and prop_Score_quantile columns into the dataframe.", {
("propensity_score" %in% names(DF))
("prop_score_quantile" %in% names(DF))
})
ATE <- 0
variance <- 0
for (q in unique(DF$prop_score_quantile)){
stratum_data <- DF[DF$prop_score_quantile == q,]
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))} else {
ATE <- 0
variance <- 0
for (stratum_data in split(DF, interaction(DF$gender, DF$country))){
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))}
}
ATE(A, 'propensity stratification')
A$propensity_score <- propensity_score(A, covariates, MinMaxScaler, TRUE)
q <- 5
A$prop_score_quantile <- with(A, cut(propensity_score, breaks = qu <- quantile(propensity_score, probs = seq(0,1, by=1/q)), labels = names(qu)[-1], include.lowest=TRUE))
ATE(A, 'propensity stratification')
# ATE
ATE <- function(DF, strata){
pop_size = nrow(DF)
if (is.null(strata)) {
return(stratified_ATE(DF, pop_size))
} else if (strata == 'propensity stratification') {
assert("For propensity score stratification you need first to add the propensity_score and prop_Score_quantile columns into the dataframe.", {
("propensity_score" %in% names(DF))
("prop_score_quantile" %in% names(DF))
})
ATE <- 0
variance <- 0
for (q in unique(DF$prop_score_quantile)){
stratum_data <- DF[DF$prop_score_quantile == q,]
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
print(stratified_ATE_variance)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))} else {
ATE <- 0
variance <- 0
for (stratum_data in split(DF, interaction(DF$gender, DF$country))){
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))}
}
A$propensity_score <- propensity_score(A, covariates, MinMaxScaler, TRUE)
q <- 5
A$prop_score_quantile <- with(A, cut(propensity_score, breaks = qu <- quantile(propensity_score, probs = seq(0,1, by=1/q)), labels = names(qu)[-1], include.lowest=TRUE))
ATE(A, 'propensity stratification')
stratified_ATE <- function(DF_group, pop_size) {
# Compute the average treatment effect on the specific stratum represented in DF_group.
# DF_group:  dataframe,
# pop_size:  size of the entire population from which the group comes from.
n_treated <- nrow(DF[DF$treatment == 1,])
n_untreated <- nrow(DF[DF$treatment == 0,])
assert("One group among treated/untreated is empty with this stratification", {
(n_treated!=0)
(n_untreated!=0)
})
avg_outcome_treated <- sum(DF_group$treatment * DF_group$Y) /  n_treated
avg_outcome_untreated <- sum((1-DF_group$treatment) * DF_group$Y) /  n_untreated
var_treated <- sum((DF_group$treatment * DF_group$Y - avg_outcome_treated)^2) / (n_treated-1)
var_untreated <- sum(((1-DF_group$treatment) * DF_group$Y - avg_outcome_untreated)^2) / (n_untreated-1)
size_group <- nrow(DF_group)
ATE_group <- (size_group/pop_size) * (avg_outcome_treated - avg_outcome_untreated)
variance_group <- (size_group/pop_size)^2 * (var_treated/n_treated + var_untreated/n_untreated)
return(c(ATE_group, variance_group))
}
stratified_ATE(DF, nrow(DF))
stratified_ATE(A, nrow(A))
head(A)
head(B)
DF$propensity_score <- propensity_score(DF, covariates, MinMaxScaler, TRUE)
q <- 5
DF$prop_score_quantile <- with(DF, cut(propensity_score, breaks = qu <- quantile(propensity_score, probs = seq(0,1, by=1/q)), labels = names(qu)[-1], include.lowest=TRUE))
ATE(DF, 'propensity stratification')
# ATE
ATE <- function(DF, strata){
pop_size = nrow(DF)
if (is.null(strata)) {
return(stratified_ATE(DF, pop_size))
} else if (strata == 'propensity stratification') {
assert("For propensity score stratification you need first to add the propensity_score and prop_Score_quantile columns into the dataframe.", {
("propensity_score" %in% names(DF))
("prop_score_quantile" %in% names(DF))
})
ATE <- 0
variance <- 0
for (q in unique(DF$prop_score_quantile)){
stratum_data <- DF[DF$prop_score_quantile == q,]
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))} else {
ATE <- 0
variance <- 0
for (stratum_data in split(DF, interaction(DF$gender, DF$country))){
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))}
}
ATE(DF, 'propensity stratification')
ATE(DF, NULL)
# ATE
ATE <- function(DF, strata){
pop_size = nrow(DF)
if (is.null(strata)) {
return(stratified_ATE(DF, pop_size))
} else if (strata == 'propensity stratification') {
assert("For propensity score stratification you need first to add the propensity_score and prop_Score_quantile columns into the dataframe.", {
("propensity_score" %in% names(DF))
("prop_score_quantile" %in% names(DF))
})
ATE <- 0
variance <- 0
for (q in unique(DF$prop_score_quantile)){
stratum_data <- DF[DF$prop_score_quantile == q,]
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))} else {
ATE <- 0
variance <- 0
# Change the columns to group on in interaction below:
for (stratum_data in split(DF, interaction(DF$gender))){
stratified_ATE_variance <- stratified_ATE(stratum_data, pop_size)
ATE_stratum <- stratified_ATE_variance[1]
variance_stratum <- stratified_ATE_variance[2]
ATE = ATE + ATE_stratum
variance = variance + variance_stratum}
return(c(ATE, variance))}
}
ATE(DF, c('gender'))
matchings <- linking_score(A, B, identifiers, match, unmatch)
sort(unique(matchings$score))
rev(sort(unique(matchings$score)))
for (score in rev(sort(unique(matchings$scores)))){
best_matches <- matchings$A[matchings$scores==score]
}
for (score in rev(sort(unique(matchings$scores)))){
best_matches <- matchings$A[matchings$scores==score]
from_A <- A[best_matches,]
print(head(from_A))
from_B <- B[matchings$B[best_matches],]$Y
print(head(from_B))
}
for (score in rev(sort(unique(matchings$scores)))){
best_matches <- matchings$A[matchings$scores==score]
from_A <- A[best_matches,]
print(head(from_A))
from_B <- B[matchings$B[best_matches],]
print(head(from_B))
}
rev(sort(unique(matchings$scores)))
best_matches <- matchings$A[matchings$scores==2.594542]
from_A <- A[best_matches,]
print(head(from_A))
from_B <- B[matchings$B[best_matches],]
print(head(from_B))
for (score in rev(sort(unique(matchings$scores)))){
best_matches <- matchings$A[matchings$scores==score]
print(best_matches)
from_A <- A[best_matches,]
print(head(from_A))
from_B <- B[matchings$B[best_matches],]
print(head(from_B))
}
